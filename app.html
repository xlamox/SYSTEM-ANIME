<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <title>RISE SYSTEMâ„¢</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@200..800&family=IBM+Plex+Sans+Arabic:wght@100..700&display=swap" rel="stylesheet">

  <style>
    :root{
      --background: 235 35% 6%;
      --foreground: 210 40% 96%;
      --chart-1: 195 100% 55%;
      --chart-2: 280 85% 64%;
      --chart-3: 155 80% 48%;
      --chart-4: 35 95% 58%;
      --chart-5: 0 84% 60%;
      --font-sans: "IBM Plex Sans Arabic", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --font-display: "Oxanium", "IBM Plex Sans Arabic", system-ui, sans-serif;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font-sans);
      color:hsl(var(--foreground));
      background:hsl(var(--background));
      overflow-x:hidden;
    }

    .bg-anim{
      position:fixed;
      inset:-18%;
      z-index:-2;
      background:
        radial-gradient(1200px 900px at 20% 25%, hsl(var(--chart-2) / 0.22), transparent 60%),
        radial-gradient(1100px 850px at 80% 30%, hsl(var(--chart-1) / 0.22), transparent 62%),
        radial-gradient(1000px 800px at 25% 85%, hsl(var(--chart-3) / 0.18), transparent 60%),
        radial-gradient(900px 700px at 85% 80%, hsl(var(--chart-4) / 0.10), transparent 62%),
        linear-gradient(to bottom, hsl(235 35% 6%), hsl(240 32% 7%));
      background-size: 140% 140%;
      animation: spaceDrift 18s ease-in-out infinite;
      transform: translateZ(0);
      will-change: transform, filter, background-position;
    }
    .bg-anim::before{
      content:"";
      position:absolute; inset:0;
      background:
        conic-gradient(from 210deg at 50% 50%,
          transparent 0deg,
          hsl(var(--chart-1) / 0.07) 70deg,
          transparent 140deg,
          hsl(var(--chart-2) / 0.07) 220deg,
          transparent 360deg);
      filter: blur(20px);
      opacity: .95;
      animation: nebulaSpin 28s linear infinite;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    .bg-anim::after{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 10% 20%, rgba(255,255,255,.12) 0 1px, transparent 2px),
        radial-gradient(circle at 35% 40%, rgba(255,255,255,.10) 0 1px, transparent 2px),
        radial-gradient(circle at 70% 25%, rgba(255,255,255,.12) 0 1px, transparent 2px),
        radial-gradient(circle at 85% 55%, rgba(255,255,255,.10) 0 1px, transparent 2px),
        radial-gradient(circle at 20% 80%, rgba(255,255,255,.10) 0 1px, transparent 2px),
        radial-gradient(circle at 55% 78%, rgba(255,255,255,.08) 0 1px, transparent 2px);
      opacity:.55;
      filter: blur(.2px);
      animation: starsFloat 14s ease-in-out infinite;
      pointer-events:none;
    }

    @keyframes spaceDrift{
      0%   { background-position: 45% 55%; transform: scale(1); filter: hue-rotate(0deg); }
      50%  { background-position: 60% 40%; transform: scale(1.03); filter: hue-rotate(10deg); }
      100% { background-position: 45% 55%; transform: scale(1); filter: hue-rotate(0deg); }
    }
    @keyframes nebulaSpin{ from{ transform: rotate(0deg); } to{ transform: rotate(360deg); } }
    @keyframes starsFloat{
      0%   { transform: translate(0px,0px); opacity:.50; }
      50%  { transform: translate(14px,-10px); opacity:.60; }
      100% { transform: translate(0px,0px); opacity:.50; }
    }

    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .wrap{max-width:1100px; margin:0 auto; padding:28px 16px 40px;}

    .header{position:relative}
    .hero-glow{
      position:absolute; top:-40px; left:50%; transform:translateX(-50%);
      width:760px; height:200px; border-radius:999px;
      background: radial-gradient(circle at center, hsl(var(--chart-1) / 0.28), transparent 62%);
      filter: blur(22px);
      pointer-events:none;
      opacity:.9;
    }

    .top-row{display:flex; gap:16px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap;}

    .badge{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 12px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      font-size:12px; color: rgba(255,255,255,.92);
    }
    .dot{width:10px;height:10px;border-radius:50%; background:hsl(var(--chart-1)); box-shadow: 0 0 18px hsl(var(--chart-1) / .60);}
    .brand-name{font-family:var(--font-display); letter-spacing:.6px}
    .brand-sub{color:rgba(255,255,255,.60)}

    .title{margin:12px 0 6px; font-family:var(--font-display); font-size:40px; line-height:1.1;}
    .subtitle{margin:0; max-width:680px; color:rgba(255,255,255,.78); font-size:14.5px; line-height:1.7;}

    .chips{margin-top:12px; display:flex; flex-wrap:wrap; gap:8px;}
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      font-size:12px; color: rgba(255,255,255,.82);
    }
    .chip-mono{font-family: ui-monospace, monospace; color: rgba(255,255,255,.92)}

    .stats{display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; width:360px; max-width:100%;}
    .stat{
      border-radius:18px; padding:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
    }
    .stat-k{font-size:11px; letter-spacing:2px; color: rgba(255,255,255,.72)}
    .stat-v{margin-top:6px; font-family:var(--font-display); font-size:22px}
    .stat-s{margin-top:4px; font-size:11px; color: rgba(255,255,255,.66)}
    .stat-hp{border-color:hsl(var(--chart-3) / .35); background:hsl(var(--chart-3) / .12)}
    .stat-level{border-color:hsl(var(--chart-1) / .35); background:hsl(var(--chart-1) / .12)}
    .stat-rank{border-color:hsl(var(--chart-2) / .35); background:hsl(var(--chart-2) / .12)}

    .locked{
      margin-top:16px; border-radius:18px;
      border:1px solid hsl(var(--chart-5) / .35);
      background:hsl(var(--chart-5) / .12);
      padding:10px 14px;
    }
    .locked-row{display:flex; justify-content:space-between; align-items:center; gap:10px; color: rgba(255,255,255,.95); font-size:13px;}

    .main{margin-top:22px; display:grid; gap:14px; grid-template-columns:1.35fr .65fr;}
    @media (max-width:980px){ .main{grid-template-columns:1fr} }

    .card{
      border-radius:24px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      padding:14px;
    }

    .label{font-size:11px; letter-spacing:2px; color: rgba(255,255,255,.70)}
    .section-title{margin-top:6px; font-family:var(--font-display); font-size:18px}
    .muted{color: rgba(255,255,255,.70); font-size:12px}
    .tiny{display:flex; justify-content:space-between; gap:10px; color: rgba(255,255,255,.64); font-size:11px}

    .card-row{display:flex; gap:12px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap;}
    .quote{margin-top:6px; font-family:var(--font-display); font-size:18px; color: rgba(255,255,255,.95);}

    .progress-row{display:flex; gap:14px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap;}
    .big{margin-top:6px; font-family: var(--font-display); font-size:34px}

    .progress-side{width:280px; max-width:100%}
    .bar{width:100%; height:10px; border-radius:999px; background: rgba(255,255,255,.12); overflow:hidden;}
    .fill{height:100%; width:0%; background:hsl(var(--chart-1)); box-shadow: 0 0 18px hsl(var(--chart-1)/.35); transition: width .25s ease; }

    .task-list{margin-top:12px; display:grid; gap:10px;}
    .task{border-radius:18px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); padding:12px;}
    .task-top{display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;}

    .tag{
      display:inline-flex; align-items:center; gap:8px;
      border-radius:999px; border:1px solid rgba(255,255,255,.18);
      padding:6px 10px; font-size:11px;
    }
    .tag.ph{background:hsl(var(--chart-3)/.16); color:hsl(var(--chart-3)); border-color:hsl(var(--chart-3)/.28)}
    .tag.iq{background:hsl(var(--chart-1)/.16); color:hsl(var(--chart-1)); border-color:hsl(var(--chart-1)/.28)}
    .tag.sp{background:hsl(var(--chart-2)/.16); color:hsl(var(--chart-2)); border-color:hsl(var(--chart-2)/.28)}

    .task-title{font-family:var(--font-display); font-size:15px; color: rgba(255,255,255,.96); max-width:360px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
    .task-meta{margin-top:6px; display:flex; flex-wrap:wrap; gap:10px; font-size:11px; color: rgba(255,255,255,.70)}

    .task-controls{display:flex; align-items:center; gap:8px;}
    .input{
      width:100%; padding:10px 12px; border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.96);
      outline:none;
    }
    .input:disabled{opacity:.6}
    .small{width:92px; padding:8px 10px; border-radius:14px;}

    .btn{
      cursor:pointer; border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.96);
      padding:10px 14px;
      border-radius:18px;
      transition:.15s;
    }
    .btn:hover{background: rgba(255,255,255,.10)}
    .btn:disabled{opacity:.55; cursor:not-allowed}
    .btn-ghost{background: rgba(255,255,255,.06)}
    .btn-green{
      width:44px; padding:10px 0;
      border-color:hsl(var(--chart-3)/.30);
      background:hsl(var(--chart-3)/.18);
    }
    .btn-green:hover{background:hsl(var(--chart-3)/.24)}

    .add-grid{margin-top:12px; display:grid; gap:10px; grid-template-columns: 1.4fr .6fr .6fr .6fr .2fr;}
    @media (max-width:980px){ .add-grid{grid-template-columns:1fr 1fr;} .btn-green{width:100%} }

    .radar-wrap{
      margin-top:10px; width:100%;
      border-radius:18px; border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      overflow:hidden; display:flex; justify-content:center; align-items:center;
      padding:8px;
    }
    .radar-wrap canvas{max-width:100%; height:auto}

    .mini-stats{margin-top:10px; display:grid; grid-template-columns:repeat(3,1fr); gap:10px;}
    .mini{border-radius:18px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); padding:10px;}
    .mini-v{font-family:var(--font-display); font-size:20px;}
    .mini-v span{font-size:12px; color: rgba(255,255,255,.55)}
    .mini-l{margin-top:4px; font-size:11px; color: rgba(255,255,255,.68)}

    .note{
      margin-top:10px; border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      padding:10px;
      color: rgba(255,255,255,.78);
      font-size:13px; line-height:1.65;
    }

    .chart-wrap{
      margin-top:10px; width:100%;
      border-radius:18px; border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      overflow:hidden;
      padding:10px;
    }
    .chart-wrap canvas{width:100%; height:auto; display:block}

    .footer{
      margin-top:18px; padding-top:14px;
      border-top:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.70);
      font-size:12px;
      display:flex; flex-direction:column; gap:6px;
    }

    .countdown{
      margin-top:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
    }
  </style>
</head>

<body>
  <div class="bg-anim"></div>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script>
    const h = React.createElement;
    const { useEffect, useMemo, useRef, useState } = React;

    const TYPE_META = {
      PH: { label: "Ù‚ÙˆØ© Ø¬Ø³Ø¯ÙŠØ©", multiplier: 2.0 },
      IQ: { label: "Ø°ÙƒØ§Ø¡ ÙˆØªØ¹Ù„Ù‘Ù…", multiplier: 1.7 },
      SP: { label: "Ø§Ù†Ø¶Ø¨Ø§Ø· ÙˆØ±ÙˆØ­Ø§Ù†ÙŠØ©", multiplier: 1.5 },
    };

    const RANKS = [
      { key: "E", days: 0,   label: "E" },
      { key: "D", days: 7,   label: "D" },
      { key: "C", days: 30,  label: "C" },
      { key: "B", days: 90,  label: "B" },
      { key: "A", days: 180, label: "A" },
      { key: "S", days: 365, label: "S Elite" },
    ];

    const RANK_PENALTY = { E:0, D:1, C:3, B:7, A:14, S:30 };

    const QUOTES = [
      "Ø£Ù†Øª Ù„Ø§ ØªØ¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ù…Ø§Ø³â€¦ Ø£Ù†Øª ØªØ¨Ù†ÙŠ Ø§Ù„Ø§Ù†Ø¶Ø¨Ø§Ø·.",
      "Ø§Ù„ÙŠÙˆÙ… Ù„ÙŠØ³ Ø§Ø®ØªØ¨Ø§Ø±Ù‹Ø§ Ù„Ù‚ÙˆØªÙƒâ€¦ Ø¨Ù„ Ù„Ø§Ù„ØªØ²Ø§Ù…Ùƒ.",
      "Ø®Ø·ÙˆØ© ÙˆØ§Ø­Ø¯Ø© ÙŠÙˆÙ…ÙŠÙ‹Ø§ ØªÙØµÙ†Ø¹ Ù…Ù†Ù‡Ø§ Ø§Ù„Ø£Ø³Ø§Ø·ÙŠØ±.",
      "ÙƒÙ„ Ù…Ù‡Ù…Ø© ØªÙÙ†Ø¬Ø²Ù‡Ø§ = Ù…Ø³ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ø´Ø®ØµÙŠØªÙƒ.",
      "Ù„Ø§ ØªÙÙØ§ÙˆØ¶ Ø¹Ù„Ù‰ Ø¹Ø§Ø¯Ø§ØªÙƒ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©.",
      "Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„Ø§ ØªØ£ØªÙŠ Ø¨Ø³Ø±Ø¹Ø©â€¦ Ù„ÙƒÙ†Ù‘Ù‡Ø§ ØªØ£ØªÙŠ Ø¨Ø«Ø¨Ø§Øª.",
      "Ø§Ù„ÙØ§Ø±Ù‚ Ø¨ÙŠÙ†Ùƒ ÙˆØ¨ÙŠÙ† Ù‡Ø¯ÙÙƒ: ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯ Ù…Ù† Ø§Ù„Ø§Ù„ØªØ²Ø§Ù….",
      "Ø§Ù„Ø¶Ø¹Ù Ù„Ø­Ø¸Ø©â€¦ ÙˆØ§Ù„Ø§Ø³ØªØ³Ù„Ø§Ù… Ù‚Ø±Ø§Ø±.",
      "Ø®ÙÙ‘Ù Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡. Ø²Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°.",
      "Ø¥Ø°Ø§ Ø¨Ø¯Ø£Øª Ø§Ù„ÙŠÙˆÙ…ØŒ Ø³ØªØ´ÙƒØ± Ù†ÙØ³Ùƒ Ø¨Ø¹Ø¯ Ø£Ø³Ø¨ÙˆØ¹.",
      "Ø¥Ù„ØªØ²Ù… Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ ØªØ´Ø¹Ø± Ø¨Ø§Ù„Ø±ØºØ¨Ø©â€”Ù‡Ù†Ø§ ØªØªØºÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ©.",
      "ÙƒÙ„ Ù…Ø±Ø© ØªÙ‚ÙˆÙ„ (Ù„Ø§Ø­Ù‚Ù‹Ø§) Ø£Ù†Øª ØªØ³Ø±Ù‚ Ù…Ù† Ù…Ø³ØªÙ‚Ø¨Ù„Ùƒ.",
      "Ù„Ø§ ØªÙ†ØªØ¸Ø± Ø§Ù„Ù…Ø²Ø§Ø¬. Ø§Ù„Ù…Ø²Ø§Ø¬ ÙŠØªØ¨Ø¹ Ø§Ù„Ø­Ø±ÙƒØ©.",
      "Ø£Ù†Øª ØªØ¨Ù†ÙŠ (Ù†Ø¸Ø§Ù…)â€¦ ÙˆÙ„ÙŠØ³ (Ù‚Ø§Ø¦Ù…Ø© Ù…Ù‡Ø§Ù…).",
      "Ø§Ù„Ø¶ØºØ· Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„ØªØ·ÙˆØ±. Ù„Ø§ ØªÙ‡Ø±Ø¨ Ù…Ù†Ù‡.",
    ];

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
    function pct(n){ return Math.round(n * 100); }

    function todayKeyLocal(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const day = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${day}`;
    }

    function randomQuote(seed){
      let hh = 0;
      for(let i=0;i<seed.length;i++) hh = (hh*31 + seed.charCodeAt(i)) >>> 0;
      return QUOTES[hh % QUOTES.length];
    }

    function expToLevel(totalExp){
      const a = 120;
      let level = 1;
      let expForNext = a;
      let remaining = totalExp;
      while(remaining >= expForNext){
        remaining -= expForNext;
        level += 1;
        expForNext = Math.round(a * Math.pow(level, 1.15));
        if(level > 200) break;
      }
      return { level, expIntoLevel: remaining, expForNext };
    }

    function rankFromStreak(days){
      let cur = RANKS[0];
      for(const r of RANKS) if(days >= r.days) cur = r;
      return cur;
    }

    function msToMidnight(){
      const now = new Date();
      const midnight = new Date(now);
      midnight.setHours(24,0,0,0);
      return midnight.getTime() - now.getTime();
    }

    function formatCountdown(ms){
      const total = Math.max(0, ms);
      const s = Math.floor(total/1000);
      const hh = Math.floor(s/3600);
      const mm = Math.floor((s%3600)/60);
      const ss = s%60;
      return `${String(hh).padStart(2,"0")}:${String(mm).padStart(2,"0")}:${String(ss).padStart(2,"0")}`;
    }

    // ===== Date helpers (local, safe) =====
    function parseKey(key){
      const [y,m,d] = String(key).split("-").map(Number);
      const dt = new Date(y, (m||1)-1, d||1);
      dt.setHours(12,0,0,0); // noon => avoids DST edge cases
      return dt;
    }
    function formatKey(dt){
      const y = dt.getFullYear();
      const m = String(dt.getMonth()+1).padStart(2,"0");
      const d = String(dt.getDate()).padStart(2,"0");
      return `${y}-${m}-${d}`;
    }
    function addDaysKey(key, days){
      const dt = parseKey(key);
      dt.setDate(dt.getDate() + days);
      return formatKey(dt);
    }
    function diffDaysKey(aKey, bKey){
      const a = parseKey(aKey).getTime();
      const b = parseKey(bKey).getTime();
      return Math.round((b - a) / (24*60*60*1000));
    }

    const STORAGE_KEY = "RISE_SYSTEM_INDEX_FULL_V7";
    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch{ return null; }
    }
    function saveState(s){ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }

    // ===== EXP scaling (fair daily cap + harsh penalty) =====
    function dailyMaxExpByLevel(level){
      return Math.round(220 + 18 * Math.log2(level + 1) + 0.8 * Math.sqrt(level));
    }
    function penaltyRatioByLevel(level){
      return clamp(0.95 + (Math.max(1, level) - 1) * 0.03, 0.95, 2.20);
    }
    function expPenaltyByLevel(level){
      const dailyMax = dailyMaxExpByLevel(level);
      return Math.round(dailyMax * penaltyRatioByLevel(level));
    }

    function computeToday(tasks, level){
      const totals = {
        scoreDone: 0,
        scoreTotal: 0,
        completion: 0,
        exp: 0,
        expMax: 0,
        weightedProgress: 0,
        byType: {PH:0, IQ:0, SP:0},
        byTypePotential: {PH:0, IQ:0, SP:0},
      };
      const SCORE_UNIT = 10;

      let wSum = 0;
      let wProg = 0;

      for(const t of tasks){
        const importance = Number(t.importance || 1);
        const weight = importance * SCORE_UNIT;

        const target = Math.max(1, Number(t.target || 1));
        const done = clamp(Number(t.done || 0), 0, target);
        const ratio = target > 0 ? (done / target) : 0;

        totals.scoreTotal += weight;
        totals.scoreDone += weight * ratio;

        const mul = TYPE_META[t.type].multiplier;
        totals.byType[t.type] += weight * ratio;
        totals.byTypePotential[t.type] += weight;

        const w = importance * mul;
        wSum += w;
        wProg += ratio * w;
      }

      totals.completion = totals.scoreTotal > 0 ? (totals.scoreDone / totals.scoreTotal) : 0;

      const dailyMax = dailyMaxExpByLevel(level);
      totals.expMax = dailyMax;
      totals.weightedProgress = wSum > 0 ? (wProg / wSum) : 0;
      totals.exp = Math.round(totals.weightedProgress * dailyMax);

      return totals;
    }

    function polygon(ctx, cx, cy, r, sides, rot){
      ctx.beginPath();
      for(let i=0;i<sides;i++){
        const a = rot + i*(2*Math.PI/sides);
        const x = cx + Math.cos(a)*r;
        const y = cy + Math.sin(a)*r;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
    }

    function RadarCanvas(props){
      const ref = useRef(null);
      const prevRef = useRef({PH:0, IQ:0, SP:0});
      const animRef = useRef(null);

      function draw(vals){
        const canvas = ref.current;
        if(!canvas) return;
        const ctx = canvas.getContext("2d");
        const w = canvas.width, hh = canvas.height;
        ctx.clearRect(0,0,w,hh);

        const cx = w/2, cy = hh/2 + 10;
        const radius = Math.min(w, hh) * 0.33;

        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;

        for(let r=1;r<=4;r++){
          polygon(ctx, cx, cy, radius*(r/4), 3, -Math.PI/2);
          ctx.stroke();
        }

        const labels = ["PH","IQ","SP"];
        const angles = [
          -Math.PI/2,
          -Math.PI/2 + (2*Math.PI/3),
          -Math.PI/2 + (4*Math.PI/3),
        ];

        labels.forEach((lab,i)=>{
          const a = angles[i];
          const x = cx + Math.cos(a)*radius;
          const y = cy + Math.sin(a)*radius;

          ctx.beginPath();
          ctx.moveTo(cx,cy);
          ctx.lineTo(x,y);
          ctx.stroke();

          ctx.fillStyle = "rgba(255,255,255,0.78)";
          ctx.font = "16px IBM Plex Sans Arabic, sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(lab, cx + Math.cos(a)*(radius+26), cy + Math.sin(a)*(radius+18));
        });

        const pPH = (vals.PH||0)/100, pIQ = (vals.IQ||0)/100, pSP = (vals.SP||0)/100;
        const arr = [pPH,pIQ,pSP].map((v,i)=>{
          const a = angles[i];
          return { x: cx + Math.cos(a)*radius*v, y: cy + Math.sin(a)*radius*v };
        });

        ctx.beginPath();
        ctx.moveTo(arr[0].x, arr[0].y);
        ctx.lineTo(arr[1].x, arr[1].y);
        ctx.lineTo(arr[2].x, arr[2].y);
        ctx.closePath();

        ctx.fillStyle = "rgba(0,229,255,0.20)";
        ctx.fill();
        ctx.strokeStyle = "rgba(0,229,255,0.88)";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = "rgba(0,229,255,0.95)";
        arr.forEach(p=>{
          ctx.beginPath();
          ctx.arc(p.x,p.y,4,0,Math.PI*2);
          ctx.fill();
        });

        ctx.restore();
      }

      useEffect(()=>{
        const next = props.values || {PH:0, IQ:0, SP:0};
        const from = prevRef.current;

        if(animRef.current) cancelAnimationFrame(animRef.current);

        const start = performance.now();
        const dur = 320;
        function lerp(a,b,t){ return a + (b-a)*t; }
        function ease(t){ return 1 - Math.pow(1-t, 3); }

        function step(now){
          const t = Math.min(1, (now - start) / dur);
          const k = ease(t);
          const cur = {
            PH: lerp(from.PH, next.PH, k),
            IQ: lerp(from.IQ, next.IQ, k),
            SP: lerp(from.SP, next.SP, k),
          };
          draw(cur);
          if(t < 1) animRef.current = requestAnimationFrame(step);
          else prevRef.current = {PH: next.PH, IQ: next.IQ, SP: next.SP};
        }
        animRef.current = requestAnimationFrame(step);

        return ()=> { if(animRef.current) cancelAnimationFrame(animRef.current); };
      }, [props.values]);

      return h("div", {className:"radar-wrap"},
        h("canvas", {ref, width:520, height:420})
      );
    }

    function CommitChart(props){
      const ref = useRef(null);
      const prevYRef = useRef(null);
      const animRef = useRef(null);

      function draw(points, t=1){
        const canvas = ref.current;
        if(!canvas) return;
        const ctx = canvas.getContext("2d");
        const w = canvas.width, hh = canvas.height;
        ctx.clearRect(0,0,w,hh);

        const pad = 18;
        const innerW = w - pad*2;
        const innerH = hh - pad*2;

        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1;
        for(let i=0;i<=4;i++){
          const y = pad + (innerH * (i/4));
          ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
        }
        ctx.restore();

        if(!points || points.length < 2){
          ctx.fillStyle = "rgba(255,255,255,0.70)";
          ctx.font = "13px IBM Plex Sans Arabic, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Ø³ÙŠØ¸Ù‡Ø± Ø§Ù„Ù…Ù†Ø­Ù†Ù‰ Ø¨Ø¹Ø¯ Ø£ÙˆÙ„ ÙŠÙˆÙ… Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ.", w/2, hh/2);
          return;
        }

        const maxY = Math.max(1, ...points.map(p=>p.y));
        const minY = Math.min(...points.map(p=>p.y));
        const range = Math.max(1, maxY - minY);

        const xs = points.map((p, i)=>{
          const x = pad + (innerW * (i/(points.length-1)));
          const yNorm = (p.y - minY) / range;
          const y = pad + innerH - (yNorm * innerH);
          return {x,y, yVal:p.y};
        });

        const prev = prevYRef.current;
        const ys = xs.map((p,i)=>{
          const py = prev && prev[i] != null ? prev[i] : p.y;
          return { x:p.x, y: py + (p.y - py)*t, yVal:p.yVal };
        });

        ctx.beginPath();
        ctx.moveTo(ys[0].x, ys[0].y);
        for(let i=1;i<ys.length;i++) ctx.lineTo(ys[i].x, ys[i].y);
        ctx.lineTo(ys[ys.length-1].x, hh-pad);
        ctx.lineTo(ys[0].x, hh-pad);
        ctx.closePath();
        ctx.fillStyle = "rgba(0,229,255,0.10)";
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(ys[0].x, ys[0].y);
        for(let i=1;i<ys.length;i++) ctx.lineTo(ys[i].x, ys[i].y);
        ctx.strokeStyle = "rgba(0,229,255,0.92)";
        ctx.lineWidth = 2.2;
        ctx.stroke();

        ctx.fillStyle = "rgba(0,229,255,0.95)";
        for(const p of ys){
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3.6, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.fillStyle = "rgba(255,255,255,0.70)";
        ctx.font = "12px IBM Plex Sans Arabic, sans-serif";
        ctx.textAlign = "right";
        ctx.fillText(`Ø§Ù„Ø¢Ù†: ${points[points.length-1].y} ÙŠÙˆÙ…`, w-pad, pad+12);

        ctx.textAlign = "left";
        ctx.fillText(`Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©: ${points[0].y} ÙŠÙˆÙ…`, pad, pad+12);
      }

      useEffect(()=>{
        const points = props.points || [];
        if(animRef.current) cancelAnimationFrame(animRef.current);

        const start = performance.now();
        const dur = 420;
        function ease(t){ return 1 - Math.pow(1-t, 3); }

        function step(now){
          const tt = Math.min(1, (now - start) / dur);
          draw(points, ease(tt));
          if(tt < 1) animRef.current = requestAnimationFrame(step);
        }
        animRef.current = requestAnimationFrame(step);

        return ()=>{ if(animRef.current) cancelAnimationFrame(animRef.current); };
      }, [props.points]);

      return h("div", {className:"chart-wrap"},
        h("canvas", {ref, width:720, height:280})
      );
    }

    function ExpChart(props){
      const ref = useRef(null);
      const animRef = useRef(null);

      function draw(points, t=1){
        const canvas = ref.current;
        if(!canvas) return;
        const ctx = canvas.getContext("2d");
        const w = canvas.width, hh = canvas.height;
        ctx.clearRect(0,0,w,hh);

        const pad = 18;
        const innerW = w - pad*2;
        const innerH = hh - pad*2;

        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1;
        for(let i=0;i<=4;i++){
          const y = pad + (innerH * (i/4));
          ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
        }
        ctx.restore();

        if(!points || points.length < 2){
          ctx.fillStyle = "rgba(255,255,255,0.70)";
          ctx.font = "13px IBM Plex Sans Arabic, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Ø³ÙŠØ¸Ù‡Ø± Ù…Ù†Ø­Ù†Ù‰ EXP Ø¨Ø¹Ø¯ Ø£ÙˆÙ„ ÙŠÙˆÙ… Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ.", w/2, hh/2);
          return;
        }

        const maxY = Math.max(1, ...points.map(p=>p.y));
        const minY = Math.min(...points.map(p=>p.y));
        const range = Math.max(1, maxY - minY);

        const pts = points.map((p,i)=>{
          const x = pad + (innerW * (i/(points.length-1)));
          const yNorm = (p.y - minY) / range;
          const y = pad + innerH - (yNorm * innerH);
          return {x,y, yVal:p.y};
        });

        const shown = pts.map(p=>({x:p.x, y: pad + innerH - ((pad + innerH - p.y) * t), yVal:p.yVal}));

        ctx.beginPath();
        ctx.moveTo(shown[0].x, shown[0].y);
        for(let i=1;i<shown.length;i++) ctx.lineTo(shown[i].x, shown[i].y);
        ctx.lineTo(shown[shown.length-1].x, hh-pad);
        ctx.lineTo(shown[0].x, hh-pad);
        ctx.closePath();
        ctx.fillStyle = "rgba(168,85,247,0.10)";
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(shown[0].x, shown[0].y);
        for(let i=1;i<shown.length;i++) ctx.lineTo(shown[i].x, shown[i].y);
        ctx.strokeStyle = "rgba(168,85,247,0.92)";
        ctx.lineWidth = 2.2;
        ctx.stroke();

        ctx.fillStyle = "rgba(168,85,247,0.95)";
        for(const p of shown){
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3.6, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.fillStyle = "rgba(255,255,255,0.70)";
        ctx.font = "12px IBM Plex Sans Arabic, sans-serif";
        ctx.textAlign = "right";
        ctx.fillText(`Net EXP Ø§Ù„Ø¢Ù†: ${Math.round(points[points.length-1].y)}`, w-pad, pad+12);
      }

      useEffect(()=>{
        const points = props.points || [];
        if(animRef.current) cancelAnimationFrame(animRef.current);

        const start = performance.now();
        const dur = 420;
        function ease(t){ return 1 - Math.pow(1-t, 3); }

        function step(now){
          const tt = Math.min(1, (now - start) / dur);
          draw(points, ease(tt));
          if(tt < 1) animRef.current = requestAnimationFrame(step);
        }
        animRef.current = requestAnimationFrame(step);

        return ()=>{ if(animRef.current) cancelAnimationFrame(animRef.current); };
      }, [props.points]);

      return h("div", {className:"chart-wrap"},
        h("canvas", {ref, width:720, height:280})
      );
    }

    function App(){
      const loaded = useMemo(()=>loadState(), []);
      const [state, setState] = useState(()=>{
        const base = {
          day: todayKeyLocal(),
          tasks: [
            { id:"t1", title:"ØµÙ„Ø§Ø©", target:5, importance:5, type:"SP", done:0 },
            { id:"t2", title:"Push-ups", target:300, importance:4, type:"PH", done:0 },
            { id:"t3", title:"Ù‚Ø±Ø§Ø¡Ø©", target:30, importance:3, type:"IQ", done:0 },
          ],
          totalExp: 0,
          hp: 100,
          commitDays: 0,
          lastCommitDay: null,
          lockedUntil: null,
          lifetimeByType: { PH:0, IQ:0, SP:0 },
          lifetimePotentialByType: { PH:0, IQ:0, SP:0 },
          commitHistory: [],
          expHistory: [],
        };
        if(loaded && typeof loaded === "object") return Object.assign({}, base, loaded);
        return base;
      });

      const [countdownMs, setCountdownMs] = useState(msToMidnight());
      useEffect(()=>{ saveState(state); }, [state]);

      useEffect(()=>{
        const t = setInterval(()=> setCountdownMs(msToMidnight()), 1000);
        return ()=>clearInterval(t);
      }, []);

      const quote = useMemo(()=>randomQuote(state.day), [state.day]);
      const level = useMemo(()=>expToLevel(state.totalExp), [state.totalExp]);
      const computed = useMemo(()=>computeToday(state.tasks, level.level), [state.tasks, level.level]);
      const rank = useMemo(()=>rankFromStreak(state.commitDays), [state.commitDays]);

      const isLocked = useMemo(()=>{
        if(!state.lockedUntil) return false;
        return Date.now() < state.lockedUntil;
      }, [state.lockedUntil, countdownMs]);

      const lockRemaining = useMemo(()=>{
        if(!state.lockedUntil) return null;
        const ms = state.lockedUntil - Date.now();
        if(ms <= 0) return null;
        const hh = Math.floor(ms/(1000*60*60));
        const mm = Math.floor((ms%(1000*60*60))/(1000*60));
        return {hh, mm};
      }, [state.lockedUntil, countdownMs]);

      function updateTask(id, patch){
        setState(prev => Object.assign({}, prev, {
          tasks: prev.tasks.map(t => t.id===id ? Object.assign({}, t, patch) : t)
        }));
      }

      function removeTask(id){
        setState(prev => Object.assign({}, prev, { tasks: prev.tasks.filter(t => t.id!==id) }));
      }

      function addTask(title, target, importance, type){
        const clean = String(title||"").trim();
        if(!clean) return;
        setState(prev => Object.assign({}, prev, {
          tasks: prev.tasks.concat([{
            id:`t${Math.random().toString(16).slice(2)}`,
            title: clean,
            target: clamp(Number(target)||1, 1, 9999),
            importance: Number(importance),
            type: type,
            done: 0
          }])
        }));
      }

      function pushHistory(history, dateKey, value){
        const arr = Array.isArray(history) ? history.slice() : [];
        if(arr.length && arr[arr.length-1].d === dateKey){
          arr[arr.length-1] = { d: dateKey, v: value };
          return arr;
        }
        arr.push({ d: dateKey, v: value });
        return arr;
      }

      // ========= No-Mercy daily close (supports multi-day catch-up) =========
      function closeOneDay(prev, dayKeyToClose, totals, qualifies, completion){
        const failHard = completion < 0.5;

        // HP
        const delta = qualifies ? 6 : (failHard ? -12 : -4);
        const hp = clamp(prev.hp + delta, 0, 100);

        // Lock: if HP hits 0 at any close, lock from NOW for 24h
        const lockedUntil = (hp === 0) ? (Date.now() + 24*60*60*1000) : prev.lockedUntil;

        // CommitDays
        const currentRank = rankFromStreak(prev.commitDays).key;
        const penaltyDays = qualifies ? 0 : (RANK_PENALTY[currentRank] ?? 0);
        const commitDays = qualifies ? (prev.commitDays + 1) : Math.max(0, prev.commitDays - penaltyDays);
        const lastCommitDay = qualifies ? dayKeyToClose : prev.lastCommitDay;

        // Lifetime radar accumulators
        const lifetimeByType = {
          PH: prev.lifetimeByType.PH + totals.byType.PH,
          IQ: prev.lifetimeByType.IQ + totals.byType.IQ,
          SP: prev.lifetimeByType.SP + totals.byType.SP
        };
        const lifetimePotentialByType = {
          PH: prev.lifetimePotentialByType.PH + totals.byTypePotential.PH,
          IQ: prev.lifetimePotentialByType.IQ + totals.byTypePotential.IQ,
          SP: prev.lifetimePotentialByType.SP + totals.byTypePotential.SP
        };

        // Net EXP
        const currLevel = expToLevel(prev.totalExp).level;
        const expPenalty = expPenaltyByLevel(currLevel);
        const totalExp = qualifies
          ? (prev.totalExp + Math.round(totals.exp))
          : Math.max(0, prev.totalExp - expPenalty);

        // Reset tasks progress after closing a day
        const tasks = prev.tasks.map(t => Object.assign({}, t, {done:0}));

        // History points
        const commitHistory = pushHistory(prev.commitHistory, dayKeyToClose, commitDays);
        const expHistory = pushHistory(prev.expHistory, dayKeyToClose, totalExp);

        return Object.assign({}, prev, {
          hp,
          lockedUntil,
          commitDays,
          lastCommitDay,
          lifetimeByType,
          lifetimePotentialByType,
          totalExp,
          tasks,
          commitHistory,
          expHistory
        });
      }

      function finalizeDayNoMercy(){
        setState(prev=>{
          const today = todayKeyLocal();
          if(prev.day === today) return prev;

          // Limit catch-up to avoid extreme loops
          const gap = diffDaysKey(prev.day, today);
          if(gap <= 0) return Object.assign({}, prev, { day: today });

          const MAX_CATCHUP = 90; // No-Mercy Ù„ÙƒÙ† Ø¨Ø¯ÙˆÙ† ØªØ¬Ù…ÙŠØ¯ Ù„Ùˆ ØºØ¨Øª Ø³Ù†ÙˆØ§Øª ğŸ˜…
          const safeGap = Math.min(gap, MAX_CATCHUP);

          let s = Object.assign({}, prev);

          // 1) Close the stored day using its saved tasks (last activity)
          {
            const currLevel = expToLevel(s.totalExp).level;
            const totals = computeToday(s.tasks, currLevel);
            const completion = totals.completion;
            const qualifies = completion >= 0.7;
            s = closeOneDay(s, s.day, totals, qualifies, completion);
          }

          // 2) For each missed day after that: full failure (no activity)
          // close days: day+1 ... day+(safeGap-1)
          for(let i=1;i<safeGap;i++){
            const dayKey = addDaysKey(prev.day, i);
            // totals = 0 activity (tasks are already reset by previous close)
            const currLevel = expToLevel(s.totalExp).level;
            const totals = computeToday(s.tasks, currLevel); // tasks done are 0 => completion 0
            const completion = 0;
            const qualifies = false;
            s = closeOneDay(s, dayKey, totals, qualifies, completion);
          }

          // 3) Set current day to today (start fresh day)
          s.day = today;

          return s;
        });
      }

      // ========= Auto (midnight + on focus + periodic) =========
      const finalizeRef = useRef(finalizeDayNoMercy);
      useEffect(()=>{ finalizeRef.current = finalizeDayNoMercy; });

      useEffect(()=>{
        let to = null;
        function scheduleMidnight(){
          if(to) clearTimeout(to);
          const ms = msToMidnight();
          to = setTimeout(()=>{
            finalizeRef.current();
            scheduleMidnight();
          }, ms + 120);
        }
        scheduleMidnight();

        const iv = setInterval(()=>{
          if(todayKeyLocal() !== state.day){
            finalizeRef.current();
          }
        }, 20000);

        function onVis(){
          if(document.visibilityState === "visible"){
            if(todayKeyLocal() !== state.day){
              finalizeRef.current();
            }
          }
        }
        function onFocus(){
          if(todayKeyLocal() !== state.day){
            finalizeRef.current();
          }
        }
        document.addEventListener("visibilitychange", onVis);
        window.addEventListener("focus", onFocus);

        // Immediate check on load
        if(todayKeyLocal() !== state.day){
          finalizeRef.current();
        }

        return ()=>{
          if(to) clearTimeout(to);
          clearInterval(iv);
          document.removeEventListener("visibilitychange", onVis);
          window.removeEventListener("focus", onFocus);
        };
      }, [state.day]);

      const radarLive = useMemo(()=>{
        const g = state.lifetimeByType;
        const p = state.lifetimePotentialByType;
        const liveGain = { PH: g.PH + computed.byType.PH, IQ: g.IQ + computed.byType.IQ, SP: g.SP + computed.byType.SP };
        const livePot  = { PH: p.PH + computed.byTypePotential.PH, IQ: p.IQ + computed.byTypePotential.IQ, SP: p.SP + computed.byTypePotential.SP };
        const ph = livePot.PH>0 ? liveGain.PH/livePot.PH : 0;
        const iq = livePot.IQ>0 ? liveGain.IQ/livePot.IQ : 0;
        const sp = livePot.SP>0 ? liveGain.SP/livePot.SP : 0;
        return { PH: Math.round(ph*100), IQ: Math.round(iq*100), SP: Math.round(sp*100) };
      }, [state.lifetimeByType, state.lifetimePotentialByType, computed.byType, computed.byTypePotential]);

      const commitPoints = useMemo(()=>{
        const hist = Array.isArray(state.commitHistory) ? state.commitHistory : [];
        return hist.map((x,i)=>({ x:i, y:Number(x.v||0), d:x.d }));
      }, [state.commitHistory]);

      const expPoints = useMemo(()=>{
        const hist = Array.isArray(state.expHistory) ? state.expHistory : [];
        return hist.map((x,i)=>({ x:i, y:Number(x.v||0), d:x.d }));
      }, [state.expHistory]);

      const [newTitle, setNewTitle] = useState("");
      const [newTarget, setNewTarget] = useState(10);
      const [newImportance, setNewImportance] = useState(3);
      const [newType, setNewType] = useState("PH");

      const expPenaltyPreview = useMemo(()=>expPenaltyByLevel(level.level), [level.level]);

      return h("div", {className:"wrap"},
        h("header", {className:"header"},
          h("div", {className:"hero-glow"}),
          h("div", {className:"top-row"},
            h("div", null,
              h("div", {className:"badge"},
                h("span", {className:"dot"}),
                h("span", {className:"brand-name"}, "RISE SYSTEMâ„¢"),
                h("span", {className:"brand-sub"}, "No-Mercy Mode")
              ),
              h("h1", {className:"title"}, "Ø·ÙˆÙ‘Ø± Ø´Ø®ØµÙŠØªÙƒâ€¦ Ù…Ø«Ù„ Ø§Ù„Ø£Ù†Ù…ÙŠ"),
              h("p", {className:"subtitle"}, "Ø§Ù„ØºÙŠØ§Ø¨ ÙŠÙØ­Ø³Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙƒÙØ´Ù„ Ù„ÙƒÙ„ ÙŠÙˆÙ… ÙØ§Øª. Ù„Ø§ Ù…Ø²Ø§Ø­."),
              h("div", {className:"chips"},
                h("div", {className:"chip"}, h("span", null, "Ø§Ù„ÙŠÙˆÙ…:"), h("span", {className:"chip-mono"}, state.day)),
                state.lastCommitDay ? h("div", {className:"chip"}, h("span", null, "Ø¢Ø®Ø± ÙŠÙˆÙ… Ù…Ø­Ø³ÙˆØ¨:"), h("span", {className:"chip-mono"}, state.lastCommitDay)) : null
              ),
              h("div", {className:"countdown"},
                h("div", {className:"muted"}, "Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø¹Ø¯:"),
                h("div", {className:"mono"}, formatCountdown(countdownMs))
              )
            ),

            h("div", {className:"stats"},
              h("div", {className:"stat stat-hp"},
                h("div", {className:"stat-k"}, "HP"),
                h("div", {className:"stat-v"}, `${state.hp}/100`),
                h("div", {className:"stat-s"}, state.hp===0 ? "Ù‚ÙÙ„ 24 Ø³Ø§Ø¹Ø©" : (state.hp>=70 ? "Ù…Ø³ØªÙ‚Ø±" : "Ø®Ø·Ø±"))
              ),
              h("div", {className:"stat stat-level"},
                h("div", {className:"stat-k"}, "LEVEL"),
                h("div", {className:"stat-v"}, String(level.level)),
                h("div", {className:"stat-s"}, `${level.expIntoLevel}/${level.expForNext} EXP`)
              ),
              h("div", {className:"stat stat-rank"},
                h("div", {className:"stat-k"}, "RANK"),
                h("div", {className:"stat-v"}, rank.label),
                h("div", {className:"stat-s"}, `${state.commitDays} ÙŠÙˆÙ… Ø§Ù„ØªØ²Ø§Ù…`)
              )
            )
          ),

          isLocked ? h("div", {className:"locked"},
            h("div", {className:"locked-row"},
              h("div", null, "ØªÙ… Ù‚ÙÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø¤Ù‚ØªÙ‹Ø§ Ø¨Ø³Ø¨Ø¨ HP = 0."),
              h("div", {className:"mono"}, lockRemaining ? `Ù…ØªØ¨Ù‚ÙŠ ${lockRemaining.hh}h ${lockRemaining.mm}m` : "...")
            )
          ) : null
        ),

        h("main", {className:"main"},
          h("section", null,
            h("div", {className:"card"},
              h("div", {className:"card-row"},
                h("div", null,
                  h("div", {className:"label"}, "QUOTE OF THE DAY"),
                  h("div", {className:"quote"}, `â€œ${quote}â€`),
                  h("div", {className:"muted", style:{marginTop:8}}, "Ø§Ù„ÙŠÙˆÙ… ÙŠÙØºÙ„Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù†Ø¯ 00:00. Ø§Ù„ØºÙŠØ§Ø¨ = Ø¹Ù‚ÙˆØ¨Ø© ÙŠÙˆÙ…ÙŠØ©.")
                )
              )
            ),

            h("div", {className:"card"},
              h("div", {className:"progress-row"},
                h("div", null,
                  h("div", {className:"label"}, "TODAY PROGRESS"),
                  h("div", {className:"big"}, `${pct(computed.completion)}%`),
                  h("div", {className:"muted"}, `EXP Ø§Ù„ÙŠÙˆÙ… (Ø¥Ø°Ø§ â‰¥70%): +${Math.round(computed.exp)} / Ø³Ù‚Ù Ø§Ù„ÙŠÙˆÙ…: ${Math.round(computed.expMax)}`),
                  h("div", {className:"muted", style:{marginTop:6}}, `Ø¹Ù‚ÙˆØ¨Ø© Net EXP Ø¥Ø°Ø§ <70% (Ù‚Ø§Ø³ÙŠØ© Ø­Ø³Ø¨ Level): -${expPenaltyPreview}`)
                ),
                h("div", {className:"progress-side"},
                  h("div", {className:"bar"},
                    h("div", {className:"fill", style:{width:`${pct(computed.completion)}%`}})
                  ),
                  h("div", {className:"tiny", style:{marginTop:8}},
                    h("span", null, "â‰¥ 70% ÙŠØ²ÙŠØ¯ HP + ÙŠÙØ­Ø³Ø¨ ÙŠÙˆÙ…"),
                    h("span", null, "< 70% = Ø®ØµÙ… Net EXP")
                  )
                )
              ),

              h("div", {className:"task-list"},
                state.tasks.map(t=>{
                  const target = Math.max(1, Number(t.target||1));
                  const done = clamp(Number(t.done||0), 0, target);
                  const itemPct = target>0 ? (done/target)*100 : 0;
                  const typeClass = t.type==="PH" ? "ph" : (t.type==="IQ" ? "iq" : "sp");
                  return h("div", {className:"task", key:t.id},
                    h("div", {className:"task-top"},
                      h("div", {style:{minWidth:0}},
                        h("div", {style:{display:"flex", alignItems:"center", gap:10, flexWrap:"wrap"}},
                          h("span", {className:`tag ${typeClass}`}, `${t.type} â€¢ imp ${t.importance}/5`),
                          h("div", {className:"task-title", title:t.title}, t.title)
                        ),
                        h("div", {className:"task-meta"},
                          h("span", null, `Target: ${t.target}`),
                          h("span", null, `Done: ${t.done}`),
                          h("span", null, `Progress: ${pct(itemPct/100)}%`)
                        )
                      ),
                      h("div", {className:"task-controls"},
                        h("div", {className:"bar", style:{width:160}},
                          h("div", {className:"fill", style:{width:`${itemPct}%`}})
                        ),
                        h("input", {
                          className:"input small",
                          type:"number",
                          min:0,
                          step:1,
                          value:t.done,
                          disabled:isLocked,
                          onChange:(e)=>updateTask(t.id, {done: clamp(Number(e.target.value||0), 0, 999999)})
                        }),
                        h("button", {className:"btn", disabled:isLocked, onClick:()=>removeTask(t.id), title:"Remove"}, "âœ•")
                      )
                    )
                  );
                })
              )
            ),

            h("div", {className:"card"},
              h("div", {className:"label"}, "ADD TASK"),
              h("div", {className:"section-title"}, "Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©"),
              h("div", {className:"muted"}, "Ø§Ù„Ø£Ù‡Ù…ÙŠØ© Ù‡ÙŠ Ø§Ù„ØªÙŠ ØªØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø¥Ù†ØµØ§Ù."),
              h("div", {className:"add-grid"},
                h("input", {className:"input", value:newTitle, disabled:isLocked, placeholder:"Ù…Ø«Ø§Ù„: Ø¯Ø±Ø§Ø³Ø© / Ù‚Ø±Ø¢Ù† / Ø¬Ø±ÙŠ", onChange:(e)=>setNewTitle(e.target.value)}),
                h("input", {className:"input", type:"number", min:1, value:newTarget, disabled:isLocked, onChange:(e)=>setNewTarget(Number(e.target.value||1))}),
                h("select", {className:"input", value:String(newImportance), disabled:isLocked, onChange:(e)=>setNewImportance(Number(e.target.value))},
                  [1,2,3,4,5].map(v=>h("option",{key:v,value:String(v)},String(v)))
                ),
                h("select", {className:"input", value:newType, disabled:isLocked, onChange:(e)=>setNewType(e.target.value)},
                  ["PH","IQ","SP"].map(v=>h("option",{key:v,value:v},v))
                ),
                h("button", {className:"btn btn-green", disabled:isLocked, onClick:()=>{
                  addTask(newTitle, newTarget, newImportance, newType);
                  setNewTitle(""); setNewTarget(10); setNewImportance(3); setNewType("PH");
                }}, "+")
              )
            ),

            h("div", {className:"card"},
              h("div", {className:"label"}, "COMMIT STATS"),
              h("div", {className:"section-title"}, "Ø£ÙŠØ§Ù… Ø§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø§Ù„Ø­Ø§Ù„ÙŠØ© + Ù…Ù†Ø­Ù†Ø§Ù‡Ø§"),
              h("div", {className:"mini-stats"},
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, state.commitDays, h("span", null, " ÙŠÙˆÙ…")),
                  h("div", {className:"mini-l"}, "Commit Days (Live)")
                ),
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, rank.label),
                  h("div", {className:"mini-l"}, "RANK Ø§Ù„Ø­Ø§Ù„ÙŠ")
                ),
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, `${commitPoints.length}`, h("span", null, " ÙŠÙˆÙ…")),
                  h("div", {className:"mini-l"}, "Ø£ÙŠØ§Ù… Ù…Ø³Ø¬Ù„Ø© Ø¨Ø§Ù„Ù…Ù†Ø­Ù†Ù‰")
                )
              ),
              h(CommitChart, {points: commitPoints})
            ),

            h("div", {className:"card"},
              h("div", {className:"label"}, "NET EXP"),
              h("div", {className:"section-title"}, "ØµØ§ÙÙŠ EXP Ø§Ù„Ù…ØªØ±Ø§ÙƒÙ…Ø© + Ù…Ù†Ø­Ù†Ø§Ù‡Ø§"),
              h("div", {className:"muted"}, "ØªØ²ÙŠØ¯ Ø¥Ø°Ø§ Ø§Ù„ÙŠÙˆÙ… â‰¥70%ØŒ ÙˆØªÙ†Ù‚Øµ Ø¥Ø°Ø§ <70% Ø¨Ø¹Ù‚ÙˆØ¨Ø© Ù‚Ø§Ø³ÙŠØ© + Ø§Ù„ØºÙŠØ§Ø¨ ÙŠÙØ¹Ø§Ù‚ÙØ¨ ÙŠÙˆÙ…ÙŠÙ‹Ø§."),
              h("div", {className:"mini-stats"},
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, Math.round(state.totalExp)),
                  h("div", {className:"mini-l"}, "Net EXP (Live)")
                ),
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, level.level),
                  h("div", {className:"mini-l"}, "Level (ÙŠØªØ£Ø«Ø± Ù…Ø¨Ø§Ø´Ø±Ø©)")
                ),
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, `-${expPenaltyPreview}`),
                  h("div", {className:"mini-l"}, "Ø¹Ù‚ÙˆØ¨Ø© Ø§Ù„ÙŠÙˆÙ… Ø¥Ø°Ø§ ÙØ´Ù„")
                )
              ),
              h(ExpChart, {points: expPoints})
            )
          ),

          h("aside", null,
            h("div", {className:"card"},
              h("div", {className:"label"}, "RADAR"),
              h("div", {className:"section-title"}, "Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ Ø§Ù„ÙƒÙ„ÙŠØ© (Live)"),
              h("div", {className:"muted"}, "All-time + Today live (ÙŠØªØ­Ø¯Ù‘Ø« ÙÙˆØ±Ù‹Ø§)."),
              h(RadarCanvas, {values: radarLive}),
              h("div", {className:"mini-stats"},
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, radarLive.PH, h("span", null, "%")),
                  h("div", {className:"mini-l"}, TYPE_META.PH.label)
                ),
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, radarLive.IQ, h("span", null, "%")),
                  h("div", {className:"mini-l"}, TYPE_META.IQ.label)
                ),
                h("div", {className:"mini"},
                  h("div", {className:"mini-v"}, radarLive.SP, h("span", null, "%")),
                  h("div", {className:"mini-l"}, TYPE_META.SP.label)
                )
              )
            ),

            h("div", {className:"card"},
              h("div", {className:"label"}, "SYSTEM NOTES"),
              h("div", {className:"note"}, "â€¢ Ø§Ù„ÙŠÙˆÙ… ÙŠÙØºÙ„Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù†Ø¯ 00:00 ÙˆÙŠØ­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬."),
              h("div", {className:"note"}, "â€¢ Ø§Ù„ØºÙŠØ§Ø¨: ÙŠÙØ­Ø³Ø¨ ÙƒÙØ´Ù„ ÙƒØ§Ù…Ù„ Ù„ÙƒÙ„ ÙŠÙˆÙ… ÙØ§Øª (No-Mercy)."),
              h("div", {className:"note"}, "â€¢ HP Rule: Ø¥Ø°Ø§ â‰¥ 70% â‡’ +6 HP + ÙŠÙØ­Ø³Ø¨ ÙŠÙˆÙ… Ø§Ù„ØªØ²Ø§Ù…. Ø¥Ø°Ø§ Ø¨ÙŠÙ† 50% Ùˆ 69% â‡’ -4 HP. Ø¥Ø°Ø§ < 50% â‡’ -12 HP."),
              h("div", {className:"note"}, "â€¢ Ø¥Ø°Ø§ HP ÙˆØµÙ„ 0 â‡’ Ù‚ÙÙ„ 24 Ø³Ø§Ø¹Ø© ÙŠØ¨Ø¯Ø£ Ø¹Ù†Ø¯ Ø¹ÙˆØ¯ØªÙƒ (Ø§Ù„Ø¢Ù†)."),
              h("div", {className:"note"}, "â€¢ Net EXP: Ø¥Ø°Ø§ â‰¥70% ØªÙØ¶Ø§Ù EXP Ø§Ù„ÙŠÙˆÙ…ØŒ ÙˆØ¥Ø°Ø§ <70% ØªÙØ®ØµÙ… EXP Ø¨Ø¹Ù‚ÙˆØ¨Ø© Ù‚Ø§Ø³ÙŠØ© ØªØ²ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ù€ Level."),
              h("div", {className:"note"}, "â€¢ RANK Ø­Ø³Ø¨ Ø£ÙŠØ§Ù… Ø§Ù„Ø§Ù„ØªØ²Ø§Ù…: D=7ØŒ C=30ØŒ B=90ØŒ A=180ØŒ S=365."),
              h("div", {className:"note"}, "â€¢ Ø¹Ù‚ÙˆØ¨Ø© Ø§Ù„Ø±Ø§Ù†Ùƒ Ø¹Ù†Ø¯ Ø¹Ø¯Ù… Ø§Ù„Ø§Ù„ØªØ²Ø§Ù…: ØªÙ†Ù‚Øµ Ø£ÙŠØ§Ù… Ø§Ù„Ø§Ù„ØªØ²Ø§Ù… Ø­Ø³Ø¨ Ø±ØªØ¨ØªÙƒ (E=0, D=1, C=3, B=7, A=14, S=30).")
            )
          )
        ),

        h("footer", {className:"footer"},
          h("div", null, "Ø­ÙØ¸ Ø¯Ø§Ø¦Ù… Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…ØªØµÙØ­ (LocalStorage)."),
          h("div", null, "RISE SYSTEMâ„¢ â€” No-Mercy Mode.")
        )
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(h(App));
  </script>
</body>
</html>
